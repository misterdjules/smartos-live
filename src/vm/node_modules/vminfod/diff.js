/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2014, Joyent, Inc. All rights reserved.
 *
 */

function objDiff(a, b, opts)
{
    var changes = [];
    var prefix;
    var ignores;
    var key;
    var ignore;
    var i;
    var nest_opts;
    var nest_changes;

    if (arguments.length === 2) {
        opts = {};
    }

    if (opts.hasOwnProperty('prefix')) {
        prefix = opts.prefix + '.';
    } else {
        prefix = '';
    }

    if (opts.hasOwnProperty('ignores')) {
        ignores = opts.ignores;
    } else {
        ignores = [];
    }

    if (a === b) {
        return ([]);
    }

    for (key in a) {

        ignore = false;

        for (i = 0; i < ignores.length; i++) {
            if (ignores[i] == (prefix + key)) {
                ignore = true;
                break;
            }
        }

        if (ignore === true) {
            continue;
        }

        if (key in b) {
            if (a[key] != b[key]) {
                if (typeof (a[key]) == 'object'
                    && typeof (b[key]) == 'object') {

                    nest_opts = {
                        prefix: prefix + key,
                        ignores: ignores
                    };

                    if (Array.isArray(a[key]) && Array.isArray(b[key])) {
                        nest_changes = arrayDiff(a[key], b[key], nest_opts);
                    } else {
                        nest_changes = objDiff(a[key], b[key], nest_opts);
                    }

                    nest_changes.forEach(function (change) {
                        changes.push(change);
                    });
                } else {
                    changes.push({
                        path: prefix + key,
                        action: 'changed',
                        from: a[key],
                        to: b[key]
                    });
                }
            }
        } else {
            changes.push({
                path: prefix + key,
                action: 'removed',
                from: a[key],
                to: null
            });
        }
    }

    for (key in b) {

        ignore = false;

        for (i = 0; i < ignores.length; i++) {
            if (ignores[i] == (prefix + key)) {
                ignore = true;
                break;
            }
        }

        if (ignore === true) {
            continue;
        }

        if (!(key in a)) {
            changes.push({
                path: prefix + key,
                action: 'added',
                from: null,
                to: b[key]
            });
        }
    }

    return (changes);
}

function arrayDiff(a, b, opts)
{
    var changes = [];
    var prefix;
    var ignores;
    var ignore;
    var i;
    var j;
    var nest_opts;
    var nest_changes;

    if (arguments.length === 2) {
        opts = {};
    }

    if (opts.hasOwnProperty('prefix')) {
        prefix = opts.prefix + '.';
    } else {
        prefix = '';
    }

    if (opts.hasOwnProperty('ignores')) {
        ignores = opts.ignores;
    } else {
        ignores = [];
    }

    if (a === b) {
        return ([]);
    }

    for (i = 0; i < a.length; i++) {

        ignore = false;

        for (j = 0; j < ignores.length; j++) {
            if (ignores[j] == (prefix + i)) {
                ignore = true;
                break;
            }
        }

        if (ignore === true) {
            continue;
        }

        if (b[i] !== undefined) {
            if (a[i] != b[i]) {
                if (typeof (a[i]) == 'object'
                    && typeof (b[i]) == 'object') {

                    nest_opts = {
                        prefix: prefix + i,
                        ignores: ignores
                    };

                    if (Array.isArray(a[i]) && Array.isArray(b[i])) {
                        nest_changes = arrayDiff(a[i], b[i], nest_opts);
                    } else {
                        nest_changes = objDiff(a[i], b[i], nest_opts);
                    }

                    nest_changes.forEach(function (change) {
                        changes.push(change);
                    });
                } else {
                    changes.push({
                        path: prefix + i,
                        action: 'changed',
                        from: a[i],
                        to: b[i]
                    });
                }
            }
        } else {
            changes.push({
                path: prefix + i,
                action: 'removed',
                from: a[i],
                to: null
            });
        }
    }

    for (i = 0; i < b.length; i++) {
        ignore = false;

        for (j = 0; j < ignores.length; j++) {
            if (ignores[j] == (prefix + i)) {
                ignore = true;
                break;
            }
        }

        if (ignore === true) {
            continue;
        }

        if (a[i] === undefined) {
            changes.push({
                path: prefix + i,
                action: 'added',
                from: null,
                to: b[i]
            });
        }
    }

    return (changes);
}

module.exports = {
    objDiff: objDiff,
    arrayDiff: arrayDiff
};