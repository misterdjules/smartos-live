/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2014, Joyent, Inc. All rights reserved.
 *
 * This module exists to watch files for changes. It is somewhat similar to
 * node's fs.watch except:
 *
 *  * FsWatcher.watch() is asynchronous and optionally can call a callback when
 *    it actually starts watching.
 *  * FsWatcher emits an error event when a file cannot be watched
 *  * FsWatcher works with files that do not exist yet, notifying you when they
 *    are created.
 *
 * To use you should do something like:
 *
 *  fsw = new FsWatcher({log: log});
 *  fsw.watch('/path/to/some/file', [callback]);
 *  fsw.unwatch('/path/to/some/file', [callback]);
 *  fsw.shutdown();
 *  fsw.on(<event type>, callback(event));
 *
 * Where the event types can be:
 *
 *  * all - for any event
 *  * create - emitted when a file is created
 *  * change - emitted when a file is modified
 *  * delete - emitted when a file is deleted
 *
 * and then
 *
 *  CREATED
 *  MODIFIED (contents)
 *  DELETED
 *
 *
 * How this works:
 *
 *   This module is a wrapper around the fswatcher tool. That tool is driven by
 *   commands on STDIN which start and stop watches on files. Output goes to
 *   STDOUT and is scraped by this module and turned into events.
 *
 *   When you FsWatcher.watch() a file first we attempt a WATCH for the file
 *   specified in the arguments. If the result is that the file does not exist,
 *   we'll try to watch the parent directory. If that doesn't exist, we'll keep
 *   going up the directory stack until we find something to watch.
 *
 *   A watch on a file that we've specifically asked to watch is here called a
 *   "primary" watch. We will keep a primary watch active until it is
 *   specifically unwatched. If we start watching parents because a primary does
 *   not exist, we call that a "secondary" watch. These secondary watches keep
 *   track of the "children" they're watching for and when an event happens on
 *   a directory we're watching as a secondary, we check to see whether the
 *   change resulted in previously non-existent primaries showing up. If so we
 *   emit a "create" event and remove the child from the secondary's list.
 *
 *   A watch can be both primary and secondary. When removing watches with
 *   unwatch we only remove primaries directly. Secondaries will be removed if
 *   the removed watch is a child and that secondary has no other children.
 *
 *   If the fswatcher child dies unexpectedly, it is restarted and all primary
 *   watches are rewatched with the timestamp of the last event we saw passed
 *   in as the 4th argument. This way fswatcher will immediately fire an event
 *   if the file was modified while the fswatcher was dying/starting.
 *
 *
 * TODO:
 *
 *   If we restart watcher and file does not exist but existed before watcher
 *   died, or if it exists now but did *not* exist before watcher died... We
 *   need to make sure we emit the create or delete event. We can detect this
 *   by checking for FAIL on first watch after restart. If there's a timestamp
 *   set, we send DELETE event right away because file must have been destroyed.
 *
 */

var assert = require('assert');
var cp = require('child_process');
var EventEmitter = require('events').EventEmitter;
var fs = require('fs');
var path = require('path');
var spawn = cp.spawn;
var util = require('util');
var vasync = require('vasync');

var FSWATCHER_CMD = '/usr/vm/sbin/fswatcher';
if (process.env.FSWATCHER_CMD) {
    FSWATCHER_CMD = process.env.FSWATCHER_CMD;
}

function FsWatcher(options)
{
    var buffers = {stdout: '', stderr: ''};
    var log = options.log;
    var self = this;

    assert(log, 'no logger passed to FsWatcher()');

    self.debug_ival = null;
    self.dedup_ns = options.dedup_ns;
    self.index = 1;
    self.log = log;
    self.pending_actions = {};
    self.prev_event = {}; // kept for deduplication
    self.watches = {};
    self.shutting_down = false;

    self.startWatcher = function () {
        log.debug({cmdline: FSWATCHER_CMD}, 'executing fswatcher');
        self.watcher = spawn(FSWATCHER_CMD, [], {stdio: 'pipe'});
        self.watcher_pid = self.watcher.pid;
        log.debug('fswatcher running with pid ' + self.watcher_pid);

        self.watcher.stdout.on('data', function (data) {
            lineChunk(data, 'stdout', function (chunk) {
                self.res_queue.push(chunk);
            });
        });

        self.watcher.stderr.on('data', function (data) {
            lineChunk(data, 'stderr', function (chunk) {
                log.trace({stderr: chunk});
            });
        });

        self.watcher.on('close', function (code, signal) {

            log.warn('fswatcher ' + self.watcher_pid + ' exited. code: ' + code
                + ' signal: ' + signal);
            self.watcher_pid = undefined;

            /*
             * If child closed unexpectedly (ie. it was not shutdown()): we'll
             * restart the child and re-add the watches here.
             */
            if (!self.shutting_down) {
                self.startWatcher();
                log.debug('trying to re-watch all watches');
                Object.keys(self.watches).forEach(function (w) {
                    log.trace('WATCH[' + w + ']: '
                        + JSON.stringify(self.watches[w]));
                    self.watches[w].secondary = false;
                    if (!self.watches[w].primary) {
                        // we only re-add primary watches, as secondary watches
                        // will get added as WATCH commands fail.
                        purgeWatch(w);
                    } else {
                        self.watches[w].running = false;
                        tryWatching(w, self.watches[w].last_event);
                    }
                });
            }
        });

        self.emit('ready', {type: 'ready'});
        self.emit('all', {type: 'ready'});
    };

    // Disabled as this outputs too much data currently
    if (0 === 1) {
        self.debug_ival = setInterval(function () {
            log.trace({
                watches: self.watches,
                pending_actions: self.pending_actions
            }, 'current state');
        }, 5000);
    }

    /*
     * For a given JSON object that came from fswatcher this dispatches
     */
    function dispatchObj(obj, callback) {
        switch (obj.type) {
            case 'event':
                handleEvent(obj, callback);
                break;
            case 'response':
                handleResponse(obj, callback);
                break;
            case 'error':
            default:
                log.warn('dispatching error!: ' + JSON.stringify(obj));
                callback();
                break;
        }
    }

    /*
     * Check whether "obj" matches the previous event. If it's the same event
     * within dedup_ns nanoseconds, returns true. If it's a different event or
     * spaced further apart, returns false.
     */
    function isDuplicate(obj) {

        if (!self.dedup_ns) {
            return (false);
        }

        /*
         * The timestamps here are generated when fswatcher is logging the
         * messages. We want to check that these are within some +/-  of a
         * previous message to be a duplicate instead of an exact match
         * to account for this inaccuracy. The worst case here however is that
         * we end up sending duplicate messages.
         */
        if ((self.prev_event.timestamp + self.dedup_ns < obj.timestamp)
            || (self.prev_event.timestamp - self.dedup_ns > obj.timestamp)) {

            return (false);
        }

        if (obj.pathname !== self.prev_event.pathname) {
            return (false);
        }

        if (obj.is_final !== self.prev_event.is_final) {
            return (false);
        }

        if (JSON.stringify(obj.changes.sort())
            !== JSON.stringify(self.prev_event.changes.sort())) {

            return (false);
        }

        return (true);
    }

    function purgeWatch(pathname) {
        var parent_dir;

        parent_dir = self.watches[pathname].parent_watch;
        if (self.watches[parent_dir]) {
            delete (self.watches[parent_dir].children)[pathname];
        }

        delete (self.watches)[pathname];
    }

    function tryWatching(pathname, start_timestamp) {
        var opts = {};

        /*
         * A primary watch gets created and destroyed only when .watch() or
         * .unwatch() is called by the caller. We only try watching here when
         * we're dealing with a file that is intentionally being watched.
         */
        if (self.watches[pathname] && self.watches[pathname].primary) {
            if (start_timestamp) {
                opts.timestamp = start_timestamp;
            }
            self.queueAction(pathname, 'WATCH', opts);
        } else {
            log.debug('Ignoring tryWatching(' + pathname + '): not primary');
        }
    }

    /*
     * Add an action to the queue for a path and attach callback if passed.
     */
    self.queueAction = function (pathname, action, opts, callback) {
        var wobj;

        self.watches[pathname].req_counter++;

        wobj = {pathname: pathname, action: action};
        if (opts && opts.timestamp && opts.timestamp > 0) {
            assert(action === 'WATCH'); // timestamp makes no sense elsewhere
            wobj.timestamp = opts.timestamp;
        }
        if (callback) {
            wobj.callback = callback;
        }
        self.req_queue.push(wobj);
    };

    function filterObject(obj) {
        log.trace({obj: obj}, 'filtering object');
        return (obj);
    }

    /*
     * pathname must be the name of a secondary watch. In which case
     * this function will:
     *
     *  - remove the secondary watch
     *  - attempt to watch each child of this secondary watch
     *
     * which could ultimately result in the secondary getting recreated
     * if any of the children do not exist.
     *
     */
    function retryAllChildren(pathname) {
        var children = [];

        children = self.watches[pathname].children;
        self.watches[pathname].children = [];
        self.watches[pathname].secondary = false;

        /*
         * We're basically treating secondary watches as one-shot watches.
         * So if we get an event that's *not* final, and we don't also have
         * a primary watch, we'll UNWATCH it. Below we're going to try
         * adding new watches for all the children which will recreate this
         * watch if necessary.
         */
        if (!self.watches[pathname].primary) {
            if (self.watches[pathname].running) {
                self.queueAction(pathname, 'UNWATCH');
            } else {
                delete (self.watches)[pathname];
            }
        }

        /* Queue a new WATCH for each child we had on this secondary */
        Object.keys(children).forEach(function (child) {
            if (self.watches[child] && self.watches[child].primary) {
                delete (self.watches[child]).parent_watch;
                tryWatching(child);
            }
        });
    }

    function handleEvent(obj, done) {
        var fobj;
        var pathname = obj.pathname;

        /* Try to avoid sending 2 identical messages when possible. */
        if (self.prev_event && isDuplicate(obj)) {
            log.trace({evt: obj}, 'ignoring duplicate event');
            done();
            return;
        }
        self.prev_event = obj;

        if (!self.watches.hasOwnProperty(pathname)) {
            log.warn({evt: obj}, 'ignoring event for unwatched file');
            done();
            return;
        }

        self.watches[pathname].last_event = obj.timestamp;

        /* remove/rename fields to match what we expose */
        fobj = filterObject(obj);

        /* only publish the event if it's a primary */
        if (self.watches[pathname].primary) {

            if (fobj.changes.indexOf('FILE_MODIFIED') !== -1) {
                fobj.type = 'change';
                self.emit('change', fobj);
            }
            if (fobj.changes.indexOf('FILE_RENAME_TO') !== -1) {
                fobj.type = 'change';
                self.emit('change', fobj);
            }
            if (fobj.changes.indexOf('FILE_DELETE') !== -1) {
                fobj.type = 'delete';
                self.emit('delete', fobj);
            }
            if (fobj.changes.indexOf('UNMOUNTED') !== -1) {
                fobj.type = 'delete';
                self.emit('delete', fobj);
            }

            // Send everything to the "all" channel
            self.emit('all', fobj);
        }

        /*
         * Whenever we get a "final" event, we're not going to get any more
         * events for this path until we start watching again.
         */
        if (self.watches[pathname] && fobj.is_final) {
            self.watches[pathname].running = false;
        }

        /*
         * If we got an event for a secondary watch, retry watching all the
         * children we're parent for.
         */
        if (self.watches[pathname] && self.watches[pathname].secondary) {
            retryAllChildren(pathname);
        }

        if (self.watches[pathname] && self.watches[pathname].primary) {
            if (fobj.is_final) {
                /*
                 * is_final means that the fswatcher is not going to rearm,
                 * possibly because the file was deleted. We attempt to re-add
                 * the watch here in this case which will cause a result and if
                 * we can't watch this file itself, we'll end up creating the
                 * appropriate secondary watch.
                 */
                if (self.watches[pathname].parent_watch) {
                    self.divorceParent(fobj.pathname);
                }
                tryWatching(fobj.pathname);
            }
        }

        done();
    }

    self.divorceParent = function (pathname) {
        var children;
        var parent_dir;

        parent_dir = self.watches[pathname].parent_watch;
        delete (self.watches[pathname]).parent_watch;
        if (self.watches[parent_dir]) {
            delete (self.watches[parent_dir].children)[pathname];
            children = self.watches[parent_dir].children;
            if (Object.keys(children).length === 0) {
                self.watches[parent_dir].secondary = false;
            }
            if (self.watches[parent_dir].secondary === false
                && self.watches[parent_dir].primary === false) {

                if (self.watches[parent_dir].running) {
                    self.queueAction(parent_dir, 'UNWATCH', {}, function () {
                        if (self.watches[parent_dir]
                            && self.watches[parent_dir].running) {
                            log.warn('watch for ' + parent_dir
                                + ' still running after unwatch');
                        }
                    });
                } else {
                    delete (self.watches)[parent_dir];
                }
            }
        }
    };

    function handleResponse(obj, done) {
        var action;
        var callback;
        var children = {};
        var err;
        var fobj;
        var parent_dir;

        if (!self.pending_actions[obj.key]) {
            log.warn({
                obj: obj,
                watch: self.watches[obj.pathname]
            }, 'no pending action for ' + obj.pathname + ' ignoring response');

            done();
            return;
        }

        if (!self.watches[obj.pathname]) {
            log.warn({
                obj: obj,
                watch: self.watches[obj.pathname]
            }, 'no watcher found for ' + obj.pathname + ' ignoring response');

            done();
            return;
        }

        log.trace({
            obj: obj,
            watch: self.watches[obj.pathname],
            pending_action: self.pending_actions[obj.key]
        }, 'handling response');

        self.watches[obj.pathname].req_counter--;

        parent_dir = path.dirname(obj.pathname);

        action = self.pending_actions[obj.key].action;
        callback = self.pending_actions[obj.key].callback;
        delete (self.pending_actions)[obj.key];

        if (obj.result == 'FAIL') {

            if (action === 'UNWATCH') {
                err = new Error('failed to unwatch ' + obj.pathname);
                if (!obj.message || !(obj.message.match(/not watching/))
                    || obj.message.match(/No such file or directory/)) {

                    log.error({obj: obj}, err.message);
                } else {
                    log.info({obj: obj}, 'succeded to unwatch ' + obj.pathname);
                    if (self.watches[obj.pathname]) {
                        self.watches[obj.pathname].running = false;

                        /*
                         * There is a race condition here. It is possible that
                         * between the time an unwatch is submitted and the
                         * result is returned, another watch could have failed
                         * and used this watch as a secondary parent watch.
                         * Because of this possibility, we will only remove
                         * the watch completely IF there aren't any children.
                         * Otherwise we will just downgrade the watch to a
                         * secondary-only watch.
                         */
                        children = self.watches[obj.pathname].children;
                        if (Object.keys(children).length === 0) {
                            delete (self.watches)[obj.pathname];
                        } else {
                            self.watches[obj.pathname].primary = false;
                        }
                    }
                }

                if (callback) {
                    callback(err);
                }
                done();
                return;
            }

            assert(action === 'WATCH');

            assert(obj.pathname !== parent_dir);

            if (self.watches[obj.pathname]
                && self.watches[obj.pathname].primary) {

                /*
                 * Attempt to watch primary failed, add secondary watch with
                 * this as child.
                 */
                if (!self.watches[parent_dir]) {
                    self.watches[parent_dir] = {
                        children: {},
                        primary: false,
                        running: false,
                        secondary: true,
                        req_counter: 0
                    };
                }

                /* Link parent to child and vice versa. */
                self.watches[parent_dir].secondary = true;
                self.watches[parent_dir].children[obj.pathname] = true;
                self.watches[obj.pathname].parent_watch = parent_dir;

                if (!self.watches[parent_dir].running) {
                    self.queueAction(parent_dir, 'WATCH');
                }

                /*
                 * The initial WATCH failed, but we've now queued a watch for
                 * the parent, so we'll call callback now since watch is
                 * effectively running.
                 */
                if (callback) {
                    callback();
                }

                done();
            } else if (self.watches[obj.pathname]
                && self.watches[obj.pathname].secondary) {

                if (!self.watches[parent_dir]) {
                    self.watches[parent_dir] = {
                        children: {},
                        primary: false,
                        running: false,
                        secondary: true,
                        req_counter: 0
                    };
                }

                children = self.watches[obj.pathname].children;
                self.watches[obj.pathname].children = {};
                self.watches[obj.pathname].secondary = false;

                /*
                 * Since the primary pathnames are absolute, there's no point
                 * keeping secondarys that don't exist. We can simply attach
                 * primary watches directly to the top-most secondary that
                 * actually succeeds. So since this was a secondary watch
                 * and it failed, let's delete it.
                 */
                if (!self.watches[obj.pathname].primary
                    && self.watches[obj.pathname].req_counter === 0) {
                    delete (self.watches)[obj.pathname];
                }

                /* Link parent to child and vice versa. */
                self.watches[parent_dir].secondary = true;
                Object.keys(children).forEach(function (child) {
                    self.watches[parent_dir].children[child] = true;
                    self.watches[child].parent_watch = parent_dir;
                });

                if (!self.watches[parent_dir].running) {
                    self.queueAction(parent_dir, 'WATCH');
                }

                done();
            } else {
                log.debug({
                    pathname: obj.pathname,
                    watch: self.watches[obj.pathname]
                }, 'got FAIL result but not primary or secondary');

                if (self.watches[obj.pathname].req_counter === 0) {
                    log.debug('req_counter for ' + obj.pathname + ' '
                        + 'is 0, removing watch');
                    delete (self.watches)[obj.pathname];
                }

                done();
            }
        } else if (obj.result === 'SUCCESS') {

            if (action === 'UNWATCH') {
                log.debug({obj: obj}, 'succeded to unwatch ' + obj.pathname);
                if (self.watches[obj.pathname]) {
                    self.watches[obj.pathname].running = false;

                    /*
                     * There is a race condition here. It is possible that
                     * between the time an unwatch is submitted and the result
                     * is returned, another watch could have failed and used
                     * this watch as a secondary parent watch. Because of this
                     * possibility, we will only remove the watch completely IF
                     * there aren't any children. Otherwise we will just
                     * downgrade the watch to a secondary-only watch.
                     */
                    children = self.watches[obj.pathname].children;
                    if (Object.keys(children).length === 0) {
                        delete (self.watches)[obj.pathname];
                    } else {
                        self.watches[obj.pathname].primary = false;
                    }
                }

                /* Need to call callback() *after* we've set running = false */
                if (callback) {
                    callback();
                }

                done();
                return;
            }

            /*
             * On success we'll always call callback here since we're not going
             * to send it an error object.
             */
            if (callback) {
                callback();
            }

            assert(action === 'WATCH');

            /* This flag indicates fswatcher is watching currently */
            if (self.watches[obj.pathname]) {
                self.watches[obj.pathname].running = true;
            }

            if (self.watches[obj.pathname]
                && self.watches[obj.pathname].primary) {

                /*
                 * If we're a primary we'll check for parents, if we have one
                 * we'll divorce ourselves from them now, since we're on our
                 * own.
                 */
                if (self.watches[obj.pathname].parent_watch) {
                    self.divorceParent(obj.pathname);
                }

                if (!self.watches[obj.pathname].initial) {
                    /*
                     * We're a primary and this is not an initial watch, emit
                     * create, since file was just created.
                     */
                    fobj = filterObject(obj);
                    fobj.type = 'create';
                    self.emit('create', fobj);
                    self.emit('all', fobj);
                }

                done();
            } else if (self.watches[obj.pathname]
                && self.watches[obj.pathname].secondary
                && obj.message !== 'already watching') {

                /*
                 * When a secondary-only watch succeeds, there's a possibility
                 * that a more suitable parent exists for the children of this
                 * watch or that the actual children exist. Unfortunately this
                 * is a race condition we have to account for since we're
                 * responding to file events and responses in no predictable
                 * order. We'll try to see if that's the case and if so
                 * re-parent the child to the more accurate parent or watch the
                 * child directly. If that is not the case, then there's
                 * nothing special to do until we recieve another event for
                 * this secondary watch.
                 */
                fs.readdir(obj.pathname, function (e, files) {
                    if (e) {
                        log.error('unable to list files for secondary watch: '
                            + obj.pathname);
                        done();
                        return;
                    }

                    log.trace({files: files, pathname: obj.pathname},
                        'looking at secondary files');

                    if (!self.watches[obj.pathname]
                        || !self.watches[obj.pathname].children) {

                        log.warn('secondary watch ' + obj.pathname
                            + ' has no children');

                        done();
                        return;
                    }
                    children = self.watches[obj.pathname].children;

                    files.forEach(function (file) {
                        file = path.join(obj.pathname, file);
                        Object.keys(children).forEach(function (child) {

                            // log.debug('checking ' + file + ' vs. ' + child);
                            if (child.length < file.length) {
                                /* too short to be a match */
                                return;
                            }

                            if (child === file) {
                                log.debug(child + ' found. Divorcing parent');
                                self.divorceParent(child);
                                tryWatching(child);
                            } else if (child.substr(0, file.length) === file
                                        && child[file.length] === '/') {

                                log.debug(child + ' found a more suitable '
                                    + 'parent under ' + file
                                    + ' deleting and reparenting');

                                self.divorceParent(child);
                                tryWatching(child);
                            }
                        });
                    });

                    done();
                });
            } else {
                // XXX log this
                done();
            }
        } else {
            // XXX log this
            done();
        }

        /* no longer initial since we've seen a response */
        if (self.watches[obj.pathname]) {
            self.watches[obj.pathname].initial = false;
        }
    }

    function nextIndex() {
        if (self.index < 4294967295) {
            self.index++;
        } else {
            self.index = 1;
        }

        return (self.index);
    }

    self.req_queue = vasync.queue(function (obj, callback) {
        var action = obj.action;
        var line = '';
        var pathname = obj.pathname;
        var start_timestamp = obj.timestamp;
        var idx;

        if (!self.watcher_pid) {
            /*
             * If watcher's not running, it should be restarting, so we add a
             * small delay and requeue. Since the next object won't be processed
             * from the queue until this one calls callback anyway, this means
             * we only delay small amounts for each object until the watcher is
             * running again at which point we'll no longer get to this delay.
             */
            setTimeout(function _requeueAfterDelay() {
                log.debug('retrying for ' + JSON.stringify(obj));
                self.req_queue.push(obj);
                callback();
            }, 50);
            return;
        }

        idx = nextIndex();
        if (action === 'UNWATCH') {
            line = idx + ' UNWATCH ' + pathname;
            log.trace(line);
            try {
                if (self.watcher) {
                    self.watcher.stdin.write(line + '\n');
                }
            } catch (e) {
                log.error({unwatch_err: e}, 'failed to write UNWATCH: '
                    + e.message);
            }
        } else {
            assert(action === 'WATCH');
            line = idx + ' WATCH ' + pathname;
            if (start_timestamp) {
                line = line + ' ' + start_timestamp;
            }
            log.trace(line);
            try {
                self.watcher.stdin.write(line + '\n');
            } catch (e) {
                log.error({watch_err: e}, 'failed to write WATCH: '
                    + e.message);
            }
        }

        /*
         * Every "action" should result in a response. We track actions we've
         * requested so that we can match them up when we get responses.
         */
        self.pending_actions[idx] = {action: action, pathname: pathname};
        if (obj.callback) {
            self.pending_actions[idx].callback = obj.callback;
        }

        callback();
    }, 1);

    self.res_queue = vasync.queue(function (res, callback) {
        var obj;
        try {
            obj = JSON.parse(res);
        } catch (e) {
            log.error({
                chunk: res
            }, 'BAD JSON');
            throw e;
        }
        dispatchObj(obj, callback);
    }, 1);

    function lineChunk(data, buffer, handler) {
        var chunk;
        var chunks;

        buffers[buffer] += data.toString();
        chunks = buffers[buffer].split('\n');

        while (chunks.length > 1) {
            chunk = chunks.shift();
            handler(chunk);
        }
        buffers[buffer] = chunks.pop(); // remainder
    }

}

util.inherits(FsWatcher, EventEmitter);

FsWatcher.prototype.watch = function (pathname, callback)
{
    var err = undefined;
    var self = this;
    var log = self.log;

    if (path.normalize(pathname) != pathname) {
        callback(new Error('pathname is not normalized'));
        return;
    }

    if (path.resolve(pathname) != pathname) {
        callback(new Error('pathname must be an absolute path'));
        return;
    }

    if (self.watches[pathname]) {
        // This becomes a primary watch now whether it was or not before
        self.watches[pathname].primary = true;

        err = new Error('Already watching ' + pathname);
        log.warn(err);

        if (!self.watches[pathname].running) {
            self.queueAction(pathname, 'WATCH', {}, callback);
        } else {
            /*
             * We're not starting a watch (because it's already running)
             * so call callback now if set
             */
            if (callback) {
                callback();
            }
        }
    } else {
        self.watches[pathname] = {
            initial: true,
            primary: true,
            running: false,
            secondary: false,
            req_counter: 0
        };
        // callback will be called when we actually start watching.
        self.queueAction(pathname, 'WATCH', {}, callback);
    }
};

FsWatcher.prototype.unwatch = function (pathname, callback)
{
    var self = this;

    if (path.normalize(pathname) != pathname) {
        callback(new Error('pathname is not normalized'));
        return;
    }

    if (path.resolve(pathname) != pathname) {
        callback(new Error('pathname must be an absolute path'));
        return;
    }

    if (!self.watches.hasOwnProperty(pathname)
        || !self.watches[pathname].primary) {

        if (callback) {
            callback();
        }
        return;
    }

    if (!self.watches[pathname].secondary) {
        /*
         * In case there are any parent secondary watches, let's relieve them
         * from duty now.
         */
        self.divorceParent(pathname);

        /*
         * If we're not secondary, we only had primary watch so we can
         * totally remove the watch.
         */
        if (self.watches.running) {
            /*
             * We only need to unwatch if the watch wasn't already
             * removed as a result of a delete operation.
             */
            self.queueAction(pathname, 'UNWATCH', {}, callback);
        } else {
            /*
             * We're basically simulating a 'SUCCESS' here, since the
             * watched path has already been unwatched implicitly.
             */
            delete (self.watches)[pathname];
            if (callback) {
                callback();
            }
        }
    } else {
        /*
         * If we are secondary, we just remove the primary flag because
         * someone is depending on this watch as a parent.
         */
        self.watches[pathname].primary = false;
        /* we're not going to UNWATCH, so call callback now */
        if (callback) {
            callback();
        }
    }
};

/*
 * Return ths list of watched files.
 */
FsWatcher.prototype.watches = function ()
{
    var self = this;
    var watches = [];
    var key;

    for (key in self.watches) {
        if (self.watches[key].primary) {
            watches.push(key);
        }
    }

    return (watches);
};

FsWatcher.prototype.watcherPID = function ()
{
    var self = this;

    return (self.watcher_pid);
};

FsWatcher.prototype.start = function ()
{
    var self = this;

    return (self.startWatcher());
};

FsWatcher.prototype.shutdown = function ()
{
    var listeners = [];
    var self = this;
    var log = self.log;

    self.shutting_down = true;

    ['all', 'change', 'create', 'delete'].forEach(function (type) {
        listeners = self.listeners(type);
        log.debug('cleanup called w/ listeners(' + type + '): '
            + util.inspect(listeners));
        self.removeAllListeners(type);
    });

    log.debug('zoneevent watcher ' + self.watcher_pid + ' cleanup called');
    if (self.watcher) {
        self.watcher.stdout.destroy(); // so we don't send more 'data'
        self.watcher.stderr.destroy();
        self.watcher.removeAllListeners('exit'); // so don't fail on kill
        self.watcher.removeAllListeners('close'); // so don't fail on kill
        log.debug('killing watcher ' + self.watcher_pid);
        self.watcher.kill();
        self.watcher = null;
    }

    if (self.debug_ival) {
        clearInterval(self.debug_ival);
        self.debug_ival = null;
    }
};

module.exports = {
    FsWatcher: FsWatcher
};
