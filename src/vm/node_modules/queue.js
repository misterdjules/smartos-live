/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2015, Joyent, Inc. All rights reserved.
 *
 */

var assert = require('assert');

var Queue = module.exports = function (opts) {
    var self = this;

    if (!opts) {
        opts = {};
    }

    // total job counter across all channels
    self.working = 0;

    // the total number of concurrent jobs across all channels
    self.max_jobs = (opts.max_jobs === undefined) ? 2 : opts.max_jobs;

    // the backlog of jobs when max_jobs limit is reached
    self.backlog = [];

    // jobs are queued in channels
    self.channels = {};

    // the number of concurrent jobs per channel
    self.workers = (opts.workers === undefined) ? 1 : opts.workers;

    // lock to prevent workers from running
    self.paused = (opts.paused === undefined) ? false : opts.paused;

    // callbacks once we have confirmed pause
    self.pause_callbacks = {};

    // pause callback timers
    self.pause_timers = {};

    // a timestamp
    self.stop_at = undefined;

    // callbacks once we have confirmed fast forwarded
    self.ff_callbacks = {};

    // fast forward callback timers
    self.ff_timers = {};

    self.work = function (id) {
        var channel;
        var job;

        if (id === undefined) {
            id = 'global';
        }

        // queue is paused and we're not fast-forwarding
        if (self.paused === true && self.stop_at === undefined) {
            return;
        }

        // make sure we have a channel with that id
        if (!self.channels.hasOwnProperty(id)) {
            return;
        }

        // get the channel
        channel = self.channels[id];

        // no jobs to work
        if (channel.jobs.length === 0) {
            return;
        }

        // max concurrency
        if (channel.working === self.workers) {
            return;
        }

        job = channel.jobs.shift();

        // we've fast-forwarded
        if (self.stop_at !== undefined) {
            if (job.created_at > self.stop_at) {
                // add the job back
                channel.jobs.unshift(job);
                return;
            }
        }

        // increment the working count
        self.working++;
        channel.working++;

        // add the job into the running set
        channel.running[job.id] = job;

        // set the started_at timestamp
        job.started_at = (new Date()).toISOString();

        job.work(function () {
            var next;

            // decrement the working count
            self.working--;
            channel.working--;

            // pull the job out of the working set
            delete (channel.running)[job.id];

            // run the original callback, passing along the arguments
            job.callback.apply(null, arguments);

            // if there's anything in the backlog, pop one off and requeue
            if (self.backlog.length > 0) {
                next = self.backlog.shift();
                self.enqueue(next.id, next.job, next.callback);
            }

            // checkPaused if nothing is working
            if (channel.working === 0) {
                self.checkPaused();
            }

            // checkFastForwarded if nothing is working
            if (channel.working === 0) {
                self.checkFastForwarded();
            }

            // remove the channel if there's nothing left to do,
            // or work the next job in the list
            if (channel.jobs.length === 0) {
                delete (self.channels)[id];
            } else {
                process.nextTick(function () {
                    self.work(id);
                });
            }

        });
    };

    self.checkPaused = function () {
        var id;

        if (self.paused !== true) {
            return;
        }

        for (id in self.channels) {
            if (self.channels[id].working > 0) {
                // something is still working
                return;
            }
        }

        for (id in self.pause_callbacks) {
            // fire the callback
            self.pause_callbacks[id]();

            // clear the timeout and clean entries
            clearTimeout(self.pause_timers[id]);
            delete (self.pause_callbacks)[id];
            delete (self.pause_timers)[id];
        }
    };

    self.checkFastForwarded = function () {
        var id;
        var i;

        if (self.stop_at === undefined) {
            return;
        }

        for (id in self.channels) {
            if (self.channels[id].working > 0) {
                // something is still working
                return;
            }

            for (i = 0; i < self.channels[id].jobs.length; i++) {
                if (self.channels[id].jobs[i].created_at < self.stop_at) {
                    // something still needs to work
                    return;
                }
            }
        }

        for (id in self.ff_callbacks) {
            // fire the callback
            self.ff_callbacks[id]();

            // clear the timeout and clean entries
            clearTimeout(self.ff_timers[id]);
            delete (self.ff_callbacks)[id];
            delete (self.ff_timers)[id];
        }
    };

    self.generateId = function () {
        var i;
        var rand;
        var charCode;
        var str = "";

        for(i=0; i<10; i++){
            rand = Math.floor( Math.random() * 62 );
            charCode = rand+= rand>9? (rand<36?55:61) : 48;
            str += String.fromCharCode( charCode );
        }

        return (str);
    }

    self.timeAgo = function (timestamp) {
        var now = Date.now();
        var then = Date.parse(timestamp);
        var duration = now - then;
        var ms_in_hour = 3600000;
        var ms_in_minute = 60000;
        var ms_in_second = 1000;
        var summary = '';
        var hours;
        var minutes;
        var seconds;
        var hour_label;
        var minute_label;
        var second_label;

        hours = Math.floor(duration / ms_in_hour);
        duration = duration - (hours * ms_in_hour);
        minutes = Math.floor(duration / ms_in_minute);
        duration = duration - (minutes * ms_in_minute);
        seconds = Math.floor(duration / ms_in_second);

        if (hours > 1) {
            hour_label = 'hours';
        } else {
            hour_label = 'hour';
        }

        if (minutes > 1) {
            minute_label = 'minutes';
        } else {
            minute_label = 'minute';
        }

        if (seconds > 1) {
            second_label = 'seconds';
        } else {
            second_label = 'second';
        }

        if (hours > 0) {
            summary += hours + ' ' + hour_label;
        }

        if (minutes > 0 && seconds > 0) {
            if (hours > 0) {
                summary += ' ';
            }
            summary += minutes + ' ' + minute_label;
            summary += ' and ' + seconds + ' ' + second_label;
        } else if (minutes > 0) {
            if (hours > 0) {
                summary += 'and ';
            }
            summary += minutes + ' ' + minute_label;
        } else if (seconds > 0) {
            if (hours > 0) {
                summary += 'and ';
            }
            summary += seconds + ' ' + second_label;
        }

        if (hours === 0 && minutes === 0 && seconds === 0) {
            summary = duration + ' milliseconds';
        }

        summary += ' ago';

        return (summary);
    }

    return (self);
};

Queue.prototype.enqueue = function (id, job, description, callback) {
    var self = this;
    var channel;
    var created_at;

    // the arguments are pretty flexible, let's adjust them now
    if (arguments.length === 1) {
        // only a job was provided
        job = id;
        id = 'global';
        description = '-';
        callback = function () {};
    } else if (arguments.length === 2) {
        /*
         * One of three scenarios are possible here:
         *  1- a job and a callback are provided
         *  2- an id and a job are provided
         *  3- a job and a description are provided
         */
        if (typeof (id) === 'function'
            && typeof (job) === 'function') {
            callback = job;
            job = id;
            id = 'global';
            description = '-';
        } else if (typeof (id) !== 'function'
            && typeof (job) === 'function') {
            description = '-';
            callback = function () {};
        } else if (typeof (id) === 'function'
            && typeof (job) !== 'function') {
            description = job;
            job = id;
            id = 'global';
            callback = function () {};
        }
    } else if (arguments.length === 3) {
        /*
         * One of three scenarios are possible here:
         *  1- id is omitted
         *  2- description is omitted
         *  3- callback is omitted
         */

         if (typeof (id) === 'function') {
            callback = description;
            description = job;
            job = id;
            id = 'global';
         } else if (typeof (description) === 'function') {
            callback = description;
            description = '-';
         } else if (callback === undefined) {
            callback = function () {};
         }
    }

    // let's make sure we have all of the required arguments now
    assert(id, 'no id passed to enqueue()');
    assert(job, 'no job passed to enqueue()');
    assert(description, 'no description passed to enqueue()');
    assert(callback, 'no callback passed to enqueue()');

    created_at = (new Date()).toISOString();

    // backlog if we're over the global limit
    if (self.working >= self.max_jobs) {
        self.backlog.push({
            id: id,
            job: job,
            description: description,
            callback: callback,
            created_at: created_at
        });
        return;
    }

    // create the channel if it doesn't exist
    if (!self.channels.hasOwnProperty(id)) {
        self.channels[id] = {
            jobs: [],
            running: {},
            working: 0,
            incr: 0
        };
    }

    channel = self.channels[id];

    channel.incr++;

    channel.jobs.push({
        id: channel.incr,
        description: description,
        work: job,
        callback: callback,
        created_at: created_at,
        started_at: null
    });

    process.nextTick(function () {
        self.work(id);
    });
};

Queue.prototype.pause = function (options, callback) {
    var self = this;
    var id;
    self.paused = true;

    if (options === undefined) {
        options = {};
    }

    if (typeof (options) === 'function') {
        callback = options;
        options = {};
    }

    if (callback) {
        id = self.generateId();
        self.pause_callbacks[id] = callback;

        if (options.hasOwnProperty('timeout')) {
            self.pause_timers[id] = setTimeout(function () {
                callback(new Error('timeout duration exceeded'));
                delete (self.pause_callbacks)[id];
                delete (self.pause_timers)[id];
            }, options.timeout);
        }
    }

    self.checkPaused();
};

Queue.prototype.resume = function () {
    var self = this;
    self.paused = false;
 
    self.stop_at = undefined;
    self.pause_callbacks = [];
    self.ff_callbacks = [];

    Object.keys(self.channels).forEach(function (id) {
        self.work(id);
    });
};

Queue.prototype.fastForward = function (timestamp, options, callback) {
    var self = this;
    var id;

    if (self.paused !== true) {
        callback(new Error('cannot fastForward a queue that is not paused'));
        return;
    }

    self.stop_at = timestamp;

    if (options === undefined) {
        options = {};
    }

    if (typeof (options) === 'function') {
        callback = options;
        options = {};
    }

    if (callback) {
        id = self.generateId();
        self.ff_callbacks[id] = callback;

        if (options.hasOwnProperty('timeout')) {
            self.ff_timers[id] = setTimeout(function () {
                callback(new Error('timeout duration exceeded'));
                delete (self.ff_callbacks)[id];
                delete (self.ff_timers)[id];
            }, options.timeout);
        }
    }
    self.checkFastForwarded();
};

/*
 * Creates snapshot to represent the internal state of the queue at this
 * exact moment in time. The resulting data structure can be serialized
 * for external introspective analysis.
 */
Queue.prototype.dump = function () {
    var self = this;
    var channels = [];
    var backlog = [];
    var snapshot;

    Object.keys(self.channels).forEach(function (channel) {
        var running = [];
        var waiting = [];

        Object.keys(self.channels[channel].running).forEach(function (id) {
            var job = self.channels[channel].running[id];
            running.push({
                description: job.description,
                created: self.timeAgo(job.created_at),
                started: self.timeAgo(job.started_at)
            });
        });

        self.channels[channel].jobs.forEach(function (job) {
            waiting.push({
                description: job.description,
                created: self.timeAgo(job.created_at)
            });
        });

        channels.push({
            id: channel,
            working: self.channels[channel].working,
            running: running,
            waiting: waiting
        });
    });

    self.backlog.forEach(function (job) {
        backlog.push({
            id: job.id,
            description: job.description,
            created: self.timeAgo(job.created_at)
        });
    });

    snapshot = {
        paused: self.paused,
        working: self.working,
        max_jobs: self.max_jobs,
        channels: channels,
        backlog: backlog
    };

    return (snapshot);
};
